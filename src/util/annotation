const int EDGE_SIZE = g.num_edges();

    pair<int, int> key;
    bool found_start;
    int count, elem_cycle_begin, elem_cycle_end, value1, value2;
    vector<pair<int, int>> walk_key;
    vector<tuple3> dic_actual;
    int elem = 0;

    for (int t = 0; t < times; ++t) {
        aux_CYCLE.clear();
        walk_key.clear();
        dic_actual.clear();

        for (int i = 0; i < EDGE_SIZE; ++i){
            elem = i+t*EDGE_SIZE;
            key = func_key(EDGES[elem].v0, EDGES[elem].v1);
            aux_CYCLE[key];
            //printf("%d,%d\n", key.first, key.second);
        }

        for (int i = 0, n = CYCLE[t].size(); i < n; ++i) {
            found_start = false;
            count = 0;
            elem_cycle_begin = CYCLE[t][i].first;
            elem_cycle_end = CYCLE[t][i].second;
            //printf("begin = %d, end = %d\n", elem_cycle_begin, elem_cycle_end);
            value1 = -1;
            value2 = -1;

            walk_key.clear();
            for (int j = EDGE_SIZE-1; j >= 0; --j) {
                elem = j+t*EDGE_SIZE;

                if (elem_cycle_begin == EDGES[elem].v1 and !found_start) {
                    value1 = EDGES[elem].v0;
                    value2 = EDGES[elem].v1;
                    //cout << value1 << " " << value2 << endl;
                    key = func_key(value1, value2);
                    aux_CYCLE[key].push_back(tuple3(elem_cycle_end, count, 1));
                    count += 1;
                    found_start = true;
                } else if (found_start && (value1==EDGES[elem].v1 || elem_cycle_end==EDGES[elem].v0)){

                    value1 = EDGES[elem].v0;
                    value2 = EDGES[elem].v1;
                    key = func_key(value1, value2);

                    if (value1 != elem_cycle_end && value2 != elem_cycle_end) {
                        walk_key.insert(walk_key.begin()+0, key); // insert like stack
                        aux_CYCLE[key].push_back(tuple3(elem_cycle_end, count, 1));
                        count += 1;
                    } else {
                        found_start = false;

                        // Go back and update values
                        for (int k = 0; k < count/2; ++k) {
                            dic_actual = aux_CYCLE[walk_key[k]];
                            for (int l = 0, nl = dic_actual.size(); l < nl; ++l){
                                if (dic_actual[l].v0 == elem_cycle_end && (k+1) != dic_actual[l].v1) {
                                    aux_CYCLE[walk_key[k]][l].v1 = k+1;
                                    aux_CYCLE[walk_key[k]][l].v2 = 0;
                                }
                            }
                        }
                        break; // to the next on the vector CYCLE
                    }
                }
            }
        }
        dic_CYCLE.push_back(aux_CYCLE);
    }